#!/usr/bin/env node

const program = require('commander');
const mkdirp = require('mkdirp');
const os = require('os');
const fs = require('fs-extra');
const path = require('path');
const readline = require('readline');
const sortedObject = require('sorted-object');

const J = require('JSUS').JSUS;
const ngt = require('nodegame-game-template');

const _exit = process.exit;
const pkg = require('../package.json');
const version = pkg.version;

const isWin = /^win/.test(process.platform);

// This file is "copied" and not linked in Windows,
// therefore we need to be agnostic while loading the root path.
const root = J.resolveModuleDir('nodegame-generator');
const confFile = path.resolve(root, 'conf', 'generator.conf.json');

// Re-assign process.exit because of commander
process.exit = exit

// Mock configuration. Will be overwritten.
var conf = {
    author: 'author',
    email: 'email',
    ngDir: undefined,
    // Properties below won't be saved in conf file.
    ngVersion: undefined,
    ngGamesAvailDir: undefined,
    ngGamesEnabledDir: undefined,
};

// Available templates.
var templates = {
    dictator: 'dictator'
};

// TODO: make templates actually loading from games_available.
var templatesDir = 'TO_BE_DEFINED';

// Chosen template. Default dictator.
const DEFAULT_TEMPLATE = 'dictator';


// Full copyright string. Will be overwritten.
var fullCopyright;

// Flag if a command is passed at all.
var cmdValue;

// CLI

before(program, 'outputHelp', function () {
    this.allowUnknownOption();
});


// program
//     .command('list-templates')
//     .description('List all available game templates')
//     .action(function() {
//         var t, str;
//         console.log();
//         for (t in templates ) {
//             if (templates.hasOwnProperty(t)) {
//                 str = ' - ' + t;
//                 if (t === DEFAULT_TEMPLATE) str += '  **default**';
//                 console.log(str);
//             }
//         }
//         console.log();
//     });


program
    .version(version)
    .command('update-conf')
    .description('Updates stored configuration (author, games dir, etc.)')
    .action(function(env, options){
        createConfFile(options);
    });

program
    .version(version)
    .command('show-conf')
    .description('Shows current configuration')
    .action(function(env, options){
        loadConfFile(function() {
            showConf();
        });
    });

program
    .command('create-game [game_name] [author] [author_email]')
    .description('Creates a new game in the games directory')
    .option('    --git', 'add .gitignore')
// .option('-t, --template <template>', 'set the template for game')
    .option('-f, --force', 'force on non-empty directory')
    .option('-v, --verbose', 'verbose output')
    .action(function(gameName, author, email, options) {

        loadConfFile(function() {
            createGame({
                game: gameName,
                author: author,
                email: email,
                options: options
            });
        });

    });

/**
 * ## detectNodeGameInstallation
 *
 * Try to detect a nodeGame normal installation
 *
 * First looks 2 and then 1 directories above.
 *
 * @return {object|boolean} An object with paths, or FALSE if detection failed.
 */
function detectNodeGameInstallation() {
    let ngDir = path.resolve(root, '..', '..');
    let ngPkg = {};
    try {
        ngPkg = require(path.resolve(ngDir, 'package.json'));
    }
    catch(e) {
        ngDir = path.resolve(root, '..');
    }
    if (!ngPkg) {
        try {
            let ngPkg = require(path.resolve(ngDir, 'package.json'));
        }
        catch(e) {}
    }
    if (ngPkg.name === 'nodegame') {

        console.log('NodeGame v' + ngPkg.version +
                    ' installation detected in: ');
        console.log(ngDir);
        console.log('');

        let gameDirs = checkGameDirs(ngDir);
        if (!gameDirs) {
            console.log('However, folders games and/or games_available ' +
                        'could not be found');
        }
        else {
            return {
                ngVersion: ngPkg.version,
                ngDir: ngDir + path.sep,
                ngGamesAvailDir: gameDirs.ngGamesAvailDir,
                ngGamesEnabledDir: gameDirs.ngGamesEnabledDir
            };
        }
    }
    return false;
}


/**
 * ## checkGameDirs
 *
 * Verifies that games and games_available exist in the given folder
 *
 * @param {string} ngDir The path to the nodegame installation
 *
 * @return {object|boolean} An object with paths, or FALSE if detection failed.
 */
function checkGameDirs(ngDir) {
    let ngGamesAvail = path.resolve(ngDir, 'games_available');
    if (fs.existsSync(ngGamesAvail)) {
        let ngGames = path.resolve(ngDir, 'games');
        if (fs.existsSync(ngGames)) {
            return {
                ngGamesEnabledDir: ngGames + path.sep,
                ngGamesAvailDir: ngGamesAvail + path.sep
            };
        }
    }
    return false;
}

/**
 * Install a before function; AOP.
 */
function before(obj, method, fn) {
    var old = obj[method];

    obj[method] = function () {
        fn.call(this);
        old.apply(this, arguments);
    };
}

/**
 * Prompt for confirmation on STDOUT/STDIN
 */
function confirm(msg, callback) {
    var rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    rl.question(msg, function (input) {
        rl.close();
        callback(/^y|yes|ok|true$/i.test(input));
    });
}

/**
 * Create application at the given directory `path`.
 *
 * @param {string} template
 */
function createGameDir(template, gameName, outDir,
                       author, authorEmail, options) {

    // Number of synchronous / asynchronous operations.
    var wait = 9;
    var verbose = !!options.verbose;
    var doGit = !!options.git;
    var d = new Date();
    var year = d.getFullYear();
    var nodegameCopyright;
    var fileName;

    nodegameCopyright = 'Copyright(c) ' + year +
        ' Stefano Balietti <ste@nodegame.org>';

    // Make full copyright string.
    fullCopyright = 'Copyright(c) ' + year;
    if (author) fullCopyright += ' ' + author;
    if (authorEmail) fullCopyright += ' <' + authorEmail + '>';

    // Fix trailing slash.
    if (outDir.charAt(outDir.length) !== path.sep) outDir = outDir += path.sep;

    console.log();

    function substituteHeader(str) {
        // Backward compatible.
        str = str.replace('{AUTHOR}', author);
        str = str.replace('{AUTHOR_EMAIL}', authorEmail);
        str = str.replace('{YEAR}', year);
        // For all games.
        str = str.replace(nodegameCopyright, fullCopyright);
        return str;
    }


    function write(filePath, str, mode) {
        fs.writeFileSync(filePath, str, { mode: mode || 0666 });
        if (verbose) console.log('   \x1b[36mcreate\x1b[0m : ' + filePath);
    }

    function mkdir(dir, fn) {
        mkdirp(dir, 0755, function(err){
            if (err) throw err;
            if (verbose) console.log('   \033[36mcreate\033[0m : ' + dir);
            fn && fn();
        });
    }

    function complete() {
        var prompt, tmp;
        if (--wait) return;

        // Enable by making a link in games/.
        makeLink(outDir, path.resolve(conf.ngGamesEnabledDir, gameName));

        prompt = launchedFromCmd() ? '>' : '$';
        if (verbose) console.log();

        console.log('   \x1b[36mCopyright string\x1b[0m:');
        console.log('        ' + fullCopyright);
        console.log();

        console.log('   \x1b[36mTemplate\x1b[0m:');
        console.log('        ' + template);
        console.log();

        console.log('   \x1b[36mGame created\x1b[0m:');
        console.log('        ' + outDir.substr(0, outDir.length-1));
        console.log();

        let channel = 'channel' + path.sep;
        tmp = '        ' + channel + 'channel.secret.js.sample      -> ' +
            channel + 'channel.secret.js';
        console.log('   \x1b[36mEdit and rename\x1b[0m:');
        console.log(tmp);
        tmp = '        ' + channel +
            'channel.credentials.js.sample -> ' +
            channel + 'channel.credentials.js';
        console.log(tmp);
        console.log();

        console.log();
    }


    // Loading Templates.

    // AUTH.
    var auth = loadTemplate(template, 'auth/auth.js');
    var authSettings = loadTemplate(template, 'auth/auth.settings.js');
    var authCodes = loadTemplate(template, 'auth/auth.codes.js');

    // CHANNEL.
    var channelSettings = loadTemplate(template, 'channel/channel.settings.js');
    var channelSecret = loadTemplate(template, 'channel/channel.secret.js');
    var channelCredentials = loadTemplate(template,
                                          'channel/channel.credentials.js');

    // GAME.
    var gameStages = loadTemplate(template, 'game/game.stages.js');
    var gameSetup = loadTemplate(template, 'game/game.setup.js');
    var gameSettings = loadTemplate(template, 'game/game.settings.js');

    // GAME / client_types.
    var typePlayer = loadTemplate(template, 'game/client_types/player.js');
    var typeBot = loadTemplate(template, 'game/client_types/bot.js');
    var typeLogic = loadTemplate(template, 'game/client_types/logic.js');
    var typePhantom = loadTemplate(template, 'game/client_types/phantom.js');
    var typeAutoplay = loadTemplate(template, 'game/client_types/autoplay.js');

    // PUBLIC.
    var indexPage = loadTemplate(template, 'public/index.htm');
    var gamePage = loadTemplate(template, 'public/game.htm');
    var instrPage = loadTemplate(template, 'public/instructions.htm');
    var endPage = loadTemplate(template, 'public/end.htm');
    var indexJS = loadTemplate(template, 'public/js/index.js');

    // VIEWS.


    // WAITROOM.
    var waitroomSettings = loadTemplate(template,
                                        'waitroom/waitroom.settings.js');
    var waitroom = loadTemplate(template, 'waitroom/waitroom.js');

    // REQUIREMENTS.
    fileName = 'requirements/requirements.settings.js';
    var requirementsSettings = loadTemplate(template, fileName);
    fileName = 'requirements/requirements.room.js';
    var requirementsRoom = loadTemplate(template, fileName);
    var requirements = loadTemplate(template, 'requirements/requirements.js');

    // LEVELS.
    var levelsREADME = loadTemplate(template, 'levels/README.md');

    mkdir(outDir, function() {

        mkdir(outDir + 'data');

        // AUTH.
        mkdir(outDir + 'auth', function() {
            auth = substituteHeader(auth);
            authSettings = substituteHeader(authSettings);

            auth = auth.replace('{NAME}', gameName);

            write(outDir + 'auth/auth.js', auth);
            write(outDir + 'auth/auth.settings.js', authSettings);
            write(outDir + 'auth/auth.codes.js.sample', authCodes);
            complete();
        });

        // CHANNEL.
        mkdir(outDir + 'channel', function() {

            // Settings.
            channelSettings = substituteHeader(channelSettings);
            channelSettings = channelSettings.replace(/{NAME}/g, gameName);
            channelSettings = channelSettings.replace('{ADMIN}',
                                                      gameName + '/admin');
            write(outDir + 'channel/channel.settings.js', channelSettings);

            // Credentials.
            channelCredentials = substituteHeader(channelCredentials);
            write(outDir + 'channel/channel.credentials.js.sample',
                  channelCredentials);

            // Secret.
            channelSecret = substituteHeader(channelSecret);
            write(outDir + 'channel/channel.secret.js.sample', channelSecret);

            complete();
        });

        // GAME.
        mkdir(outDir + 'game', function() {

            gameStages = substituteHeader(gameStages);
            gameSetup = substituteHeader(gameSetup);
            gameSettings = substituteHeader(gameSettings);

            write(outDir + 'game/game.stages.js', gameStages);
            write(outDir + 'game/game.setup.js', gameSetup);
            write(outDir + 'game/game.settings.js', gameSettings);

            mkdir(outDir + 'game/client_types', function() {
                typePlayer = substituteHeader(typePlayer);
                typeBot = substituteHeader(typeBot);
                typeAutoplay = substituteHeader(typeAutoplay);
                typeLogic = substituteHeader(typeLogic);
                typePhantom = substituteHeader(typePhantom);

                write(outDir + 'game/client_types/autoplay.js', typeAutoplay);
                write(outDir + 'game/client_types/player.js', typePlayer);
                write(outDir + 'game/client_types/bot.js', typeBot);
                write(outDir + 'game/client_types/logic.js', typeLogic);
                write(outDir + 'game/client_types/phantom.js', typePhantom);
                complete();
            });
        });

        // PUBLIC.
        mkdir(outDir + 'public', function() {
            write(outDir + 'public/index.htm', indexPage);
            indexJS = substituteHeader(indexJS);
            // TODO: one command to replace all instances.
            indexJS = indexJS.replace('{NAME}', gameName);
            indexJS = indexJS.replace('{NAME}', gameName);

            instrPage = instrPage.replace('{NAME}', gameName);
            write(outDir + 'public/instructions.htm', instrPage);

            write(outDir + 'public/game.htm', gamePage);
            write(outDir + 'public/end.htm', endPage);

            // Copying favicon over.
            fs.copySync(ngt.resolve('public/favicon.ico'),
                        outDir + 'public/favicon.ico');

            mkdir(outDir + 'public/js', function() {
                write(outDir + 'public/js/index.js', indexJS);

                mkdir(outDir + 'public/css', function() {
                    complete();
                });
            });
        });

        // VIEWS.
        mkdir(outDir + 'views', function() {
            mkdir(outDir + 'views/contexts', function() {
                // Something.
                mkdir(outDir + 'views/templates', function() {
                    // Something.
                    complete();
                });
            });
        });

        // WAITROOM.
        mkdir(outDir + 'waitroom', function() {

            waitroom = substituteHeader(waitroom);
            waitroomSettings = substituteHeader(waitroomSettings);

            write(outDir + 'waitroom/waitroom.js.sample', waitroom);
            write(outDir + 'waitroom/waitroom.settings.js', waitroomSettings);

            complete();
        });

        // REQUIREMENTS.
        mkdir(outDir + 'requirements', function() {

            requirements = substituteHeader(requirements);
            requirementsSettings = substituteHeader(requirementsSettings);
            requirementsRoom = substituteHeader(requirementsRoom);

            write(outDir + 'requirements/requirements.js.sample', requirements);
            write(outDir + 'requirements/requirements.settings.js',
                  requirementsSettings);
            write(outDir + 'requirements/requirements.room.js.sample',
                  requirementsRoom);

            complete();
        });

        // LEVELS.
        mkdir(outDir + 'levels', function() {
            write(outDir + 'levels/README.md', levelsREADME);
            complete();
        });

        // Package.json
        var pkg = {
            name: gameName
            , version: '0.0.1'
            , description: 'This is a nodeGame game based on ' + template
            , author: author + ' ' + '<' + authorEmail + '>'
            , license: "MIT/X11"
            , homepage: 'http://nodegame.org'
            //             , private: true
        }


        // sort dependencies like npm(1)
        // pkg.dependencies = sortedObject(pkg.dependencies);

        // write files
        write(outDir + 'package.json', JSON.stringify(pkg, null, 4));

        if (doGit) {
            write(outDir + '.gitignore',
                  fs.readFileSync(root + '/.gitignore', 'utf-8'));
        }

        complete();
    });
}

/**
 * Copies a file to a destination
 *
 *
 *
 */
function copyTemplate(from, to) {
    from = path.join(__dirname, '..', 'templates', from);
    write(to, fs.readFileSync(from, 'utf-8'));
}

/**
 * Check if the given directory `path` is empty.
 *
 * @param {String} dir
 * @param {Function} fn
 */
function emptyDirectory(dir, fn) {
    fs.readdir(dir, function(err, files){
        if (err && 'ENOENT' != err.code) throw err;
        fn(!files || !files.length);
    });
}

/**
 * Graceful exit for async STDIO
 */
function exit(code) {
    // flush output for Node.js Windows pipe bug
    // https://github.com/joyent/node/issues/6247 is just one bug example
    // https://github.com/visionmedia/mocha/issues/333 has a good discussion
    function done() {
        if (!(draining--)) _exit(code);
    }

    var draining = 0;
    var streams = [process.stdout, process.stderr];

    exit.exited = true;

    streams.forEach(function(stream){
        // submit empty write request and wait for completion
        draining += 1;
        stream.write('', done);
    });

    done();
}

/**
 * Determine if launched from cmd.exe
 */
function launchedFromCmd() {
    return process.platform === 'win32'
        && process.env._ === undefined;
}

/**
 * ## loadTemplate
 *
 * Load template file from the templates dir, or fallback to default one.
 *
 * @param {string} template The name of the template, e.g. ultimatum
 * @param {string} file The path to the file inside the template
 *
 * @return {string} The loaded template
 */
function loadTemplate(template, file) {
    var templatePath;
    // Uncomment when loading templates from templatesDir works.
    //     templatePath = path.join(templatesDir, templates[template], file);
    //     if (!fs.existsSync(templatePath)) {
    //         // Try to use the default one.
    //         templatePath = ngt.resolve(file);
    //         if (!fs.existsSync(templatePath)) {
    //             throw new Error('Cannot find template file: ' + file);
    //         }
    //     }
    templatePath = ngt.resolve(file);
    if (!fs.existsSync(templatePath)) {
        throw new Error('Cannot find template file: ' + file);
    }
    return fs.readFileSync(templatePath, 'utf-8');
}

function templateExists(template) {
    return !!templates[template];
}

/**
 * Create game.
 *
 */
function createGame(options) {
    var author, authorEmail, destinationPath;
    var template, appName, str, opts;

    if (!options.game) {
        console.log('Error: game name missing');
        return;
    }

    if (path.isAbsolute(options.game)) {
        destinationPath = options.game;
    }
    else {
        // Is there a default game folder?
        if (!conf.ngGamesAvailDir) {
            console.log('Error: no default game folder found. Please ' +
                        'provide an absolute path for the game, or ' +
                        'set the default game folder');
            return;
        }
        destinationPath = path.resolve(conf.ngGamesAvailDir, options.game);
    }
    // App name.
    appName = path.basename(path.resolve(destinationPath));

    // Author and email as from input or as default ones.
    author = options.author || conf.author;
    authorEmail = options.email || conf.email;

    // These are the options like -f.
    opts = options.options || {};

    if (opts.template) {
        if (!templateExists(opts.template)) {
            console.log('Error: template not found: ' + opts.template);
            return;
        }
        template = opts.template;
    }
    else {
        template = DEFAULT_TEMPLATE;
    }
    // Generate game. Check if it is empty.
    emptyDirectory(destinationPath, function(empty) {

        if (empty || opts.force) {
            if (!empty) {
                console.log('  --force option: overwriting existing folder.');
            }
            createGameDir(template,
                          appName,
                          destinationPath,
                          author,
                          authorEmail,
                          opts);
        }
        else {
            colorWrite('Warning!');
            console.log('');
            str = destinationPath + ' is not empty, do '
                + 'you want to continue? [y/N] ';
            confirm(str, function(ok) {
                if (ok) {
                    process.stdin.destroy();
                    createGameDir(template,
                                  appName,
                                  destinationPath,
                                  author,
                                  authorEmail,
                                  opts);
                }
                else {
                    console.error('aborting');
                    exit(1);
                }
            });
        }
    });
}


/**
 * Create conf file
 */
function createConfFile(cb) {

    var rl, str;

    rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    console.log('');
    str = 'Path to nodeGame installation folder: ';
    if (!conf.ngDir || ! conf.ngGamesAvailDir || !conf.ngGamesEnabledDir) {
        let ngInfo = detectNodeGameInstallation();
        if (ngInfo) J.mixin(conf, ngInfo);
    }
    if (conf.ngDir) str += '[' + conf.ngDir + '] ';

    colorWrite('Input missing information, enter to keep default');

    rl.question(str, function(answer) {

        answer = answer || conf.ngDir;

        if (!answer) {
            console.log('Error: no directory provided and no default found.');
            process.exit();
            return;
        }
        if (!path.isAbsolute(answer)) answer = path.join(process.cwd(), answer);

        if (!fs.existsSync(answer)) {
            console.log('Error: directory not existing: ' + answer);
            process.exit();
            // Must return, otherwise jumps to the next question already.
            return;
        }

        // Add trailing slashes.
        if (launchedFromCmd()) {
            if (answer.substring(answer.length-2)!== '\\') answer += '\\';
        }
        else {
            if (answer.charAt(answer.length-1) !== path.sep) answer += path.sep;
        }

        // Set nodeGame dir.
        conf.ngDir = answer;

        str = 'Default author name: ';
        if (conf.author) str += '[' + conf.author +'] ';

        rl.question(str, function(answer) {

            if (answer) conf.author = answer;

            str = 'Default author email: ';
            if (conf.email) str += '[' + conf.email +'] ';
            rl.question(str, function(answer) {

                if (answer) conf.email = answer;

                showConf(conf);

                rl.close();

                writeConfFile(conf, cb);
            });
        });
    });

//     // Normalize to absolute if not already.
//     if (!path.isAbsolute(conf.ngGamesAvailDir)) {
//         conf.ngGamesAvailDir = path.normalize(root, confFile.ngGamesAvailDir);
//     }
}

function loadTemplates() {
    let dir = conf.ngGamesAvailDir;

    fs.readdirSync(dir).forEach(function(file, index){
        let curPath = path.join(dir, file);
        //  Recurse.
        if (fs.lstatSync(curPath).isDirectory()) {
            var name;
            try {
                let packageJson = require(path.join(curPath, 'package.json'));
                name = packageJson.name;
                if (name) templates[name] = curPath;
            }
            catch(e) {
                // Ignore errors for now.
            }
        }

    });
}

function showConf(localConf) {
    localConf = localConf || conf;
    console.log('');
    colorWrite('Configuration: ');
    console.log('');
    console.log("    Games folder path: ", conf.ngGamesAvailDir);
    console.log("          Author name: ", conf.author);
    console.log("         Author email: ", conf.email);
    console.log('');
    console.log('To change run nodegame update-conf');
    console.log('');
}

function writeConfFile(conf, cb) {
    var str;
    str = JSON.stringify(conf, null, 4);
    fs.writeFile(confFile, str, function(err) {
        if (err) {
            console.log('');
            colorWrite('Error!');
            console.log('Could not write ' + confFile);
            console.log(err);
            console.log('');
            console.log('Trying to continue...');
            console.log('');
        }

        if (cb) cb();
    });
}

function loadConfFile(cb) {
    // Try to load configuration. If not found start utility to create it.
    try {
        conf = require(confFile);
        if (!conf.author || !conf.email || !conf.ngDir) {
            createConfFile(cb);
        }
        else {
            cb();
        }
    }
    catch(e) {
        console.log('');
        colorWrite('Warning!');
        console.log('nodegame-generator conf file not found or not readable');
        createConfFile(cb);
    }
}

function colorWrite(str) {
    console.log('\x1b[36m' + str + '\x1b[0m');
}

function makeLink(from, to, type) {
    if (isWin) {
        if (type === 'file') fs.linkSync(from, to, 'file');
        else fs.symlinkSync(from, to, 'junction');
    }
    else {
        fs.symlinkSync(from, to);
    }
}

// Parsing options.
program.parse(process.argv);

if (!program.args.length &&
    program.rawArgs[2] !== '--help' && program.rawArgs[2] !== '-h') {
    console.log('Error: no command provided.');
}
